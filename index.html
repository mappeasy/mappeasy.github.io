<html>

<head>
    <title>Flush FLow Frenzy: Follow the FLush </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@600&display=swap" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <link rel="stylesheet" href="flushflow.css" />
    <!-- Leaflet Esri Plugin -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/esri-leaflet"></script>
    <!-- JavaScript file -->
    <script src="script.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BHSNBW8NK6"></script>
    
    <script>
        try {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-BHSNBW8NK6');
        } catch (e) {
            console.log(e);
        }
    </script>
</head>

<body>
    <div id="loadingModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Following The Flush . . .</h2>
                <i class="fa fa-cog fa-spin fa-5x fa-fw"></i>
            </div>
            <div class="modal-body">
                <p style="font-family: Arial, sans-serif; color: #333; line-height: 1.6;">
                    <span style="color: #007bff; font-weight: bold;">Dive into Houston's hidden water kingdom!</span>
                    Imagine <span style="font-weight: bold;">39 bustling wastewater castles</span> and <span
                        style="font-weight: bold; color: #28a745;">2 special rain spas.</span>
                    <br />Picture over <span style="font-weight: bold;">380 water elevators</span> (no boring music
                    here!) and a whopping <span style="font-weight: bold;">6,500 miles of watery roads,</span> from tiny
                    2-inch streams to huge 144-inch rivers.
                    <br />These pipes could stretch <span style="font-weight: bold;">from DC to Seattle and back</span>
                    â€“ it's a mega water slide under your feet!
                    <br /> <span style="color: #dc3545; font-weight: bold;">Houston's not just a city, it's an epic H2O
                        adventure land!</span> ðŸŒŠðŸš€ðŸ’¦
                </p>
            </div>
        </div>
    </div>
    <div id="summaryCard" class="summary-card">
        <div class="card-note" id="card-note-notification">From Flush to Final Splash! Adventure Begins</div>
        <!-- Add your note text here -->
        <div class="card-content">
            <h2 id="cardHeader">Where Flush Goes</h2>
            <sub id="notification">
                <font color='gray'><i>"Imagine this: In our underground water race, the flow zooms from 1 to 3 feet per
                        second in the Gravity Main, like a lazy river, and then dashes from 2 to 8 feet per second in
                        the Forcemain, like a super-speedy waterslide!</i></font>
            </sub>
            <hr />
            <p id="generalRoute_container"><strong>General Route:</strong> <span id="generalRoute">0 feet</span></p>
            <p id="distanceTraveled_container"><strong>Zooming Adventure:</strong> <span id="distanceTraveled">0
                    feet</span></p>
            <p id="timeToWWTP_container"><strong>Speedy Splash:</strong> <span id="timeToWWTP">0 hours</span></p>
            <p id="communitiesPassed_"><strong>Epic Journey of The Flush Through Below SuperNeighborhoods:</strong></p>
            <ul id="communitiesPassed">
                <!-- List items will be added dynamically -->
            </ul>
            <button onclick="closeSummaryCard('summaryCard');">Close</button>

        </div>
    </div>
    <div id="aboutMe" class="summary-card">
        <div class="card-note">Flush Flow Frenzy: Follow the Flush</div>
        <!-- Add your note text here -->
        <div class="card-content">
            <h2 id="cardHeader_about">About this Project</h2>
            <p id="generalRoute_container_about"><span id="generalRoute_about">This is purely for learning purpose â€“ a
                    chance to track the splashy journey of our flushes from the loo to the lab! It's our way of teaching
                    the kiddos the swirling path of their flush â€“ from toilet twirls to treatment thrills! ðŸš½ðŸ’¦ðŸŽ¢ <br />
                    Double Click/Tap to flush ðŸ’©</span></p> <hr/>
            <p id="distanceTraveled_container_about"><span id="distanceTraveled_about">Made with
                        class="fa-solid fa-heart" style="color: #d31717;"></i> by WWO<br></span></p>
            <button onclick="closeSummaryCard('aboutMe')">Close</button>
        </div>
    </div>
    <div id="splashShow" class="summary-card">
        <div class="card-note">Flush Flow Frenzy: Follow the Flush</div>
        <!-- Add your note text here -->
        <div class="card-content">
            <h2 id="cardHeader_about">Flushing ðŸ’©: Super Simple </h2>
            <p id="generalRoute_container_about"><span id="generalRoute_about"> <b style="color: red;">Double Tap or
                        double click</b> on any spot to start a flush adventure, or hit the blue top-left button to
                    whoosh away from where you are!ðŸš½ðŸ’¦ðŸŽ¢</span></p>
            <p id="distanceTraveled_container_about"><span id="distanceTraveled_about">Made with <i
                        class="fa-solid fa-heart" style="color: #d31717;"></i> by WWO<br></span></p>
            <button onclick="closeSummaryCard('splashShow')">Close</button>
        </div>
    </div>
    <div id="morelgendModal" class="summary-card">
        <div class="card-note">Flush Flow Frenzy: Follow the Flush</div>
        <!-- Add your note text here -->
        <div class="card-content">
            <h2 id="cardHeader_morelgendModal">More SSO Legend</h2>
            <p id="generalRoute_container_morelgendModal"><span id="generalRoute_morelgendModal">Below reasons can cause Sewer Overflow <br />
                <i class="fa-solid fa-ghost fa-beat fa-2x" style="color:teal"></i>&nbsp;  Temporary Blockage<br/>
                <i class="fa-solid fa-ghost fa-beat fa-2x" style="color:red"></i>&nbsp;  Grease <br/>
                <i class="fa-solid fa-ghost fa-beat fa-2x" style="color:Black"></i>&nbsp;  Structural <br/>
                <i class="fa-solid fa-ghost fa-beat fa-2x" style="color:blue"></i>&nbsp;  Wet Weather <br/>
                <i class="fa-solid fa-ghost fa-beat fa-2x" style="color:purple"></i>  &nbsp; Rags/Wipes<br/>
                <i class="fa-solid fa-ghost fa-beat fa-2x" style="color:green"></i> &nbsp; Roots <br/>                
                <i class="fa-solid fa-ghost fa-beat fa-2x" style="color:yellow"></i> &nbsp; Lift Station <br/>
            </p>
            <p id="distanceTraveled_container_morelgendModal"><span id="distanceTraveled_morelgendModal">Made with <i
                        class="fa-solid fa-heart" style="color: #d31717;"></i> by WWO<br></span></p>
            <button onclick="closeSummaryCard('morelgendModal')">Close</button>
        </div>
    </div>    
    <div id="map"></div>
    <button id="currentLocationButton" title="Your Current Location"><i class="fa fa-location"></i></button>
    <button id="lastFlushButton"><i class="fas fa-water"></i> Last Flush</button>
    <div id="toggleButton" class="collapsible-button"> <i class="fas fa-chevron-down"></i> More <i
            class="fa-solid fa-poo fa-beat" style="color: #8b4513;"></i></div>
    <div id="scoreContainer" style="display: none;">
        <i class="fa-solid fa-ghost fa-2x" style="color: #db1414;"></i>
        <span id="score">0</span>
    </div>
    <div id="congratsModal" class="congrats-modal">
        <div class="congrats-message">
            <h1>Congratulations! Lift Station is under control now.</h1>
            <h4>Only Flush the "3-Ps": Pee ðŸ’§- Poo ðŸ’© - toilet Paper ðŸ§»</h4>
            <button id="closeModalButton" class="closeModalButton">OK</button>
        </div>
    </div>
    <div id="congratsModalLS" class="congrats-modal">
        <div class="congrats-message">
            <h1>Congratulations!</h1>
            <h4>Lift Station is cleaned now!</h4>
            <button id="closeModalButtonLS" class="closeModalButton">OK</button>
        </div>
    </div>
    <div id="gameOver" class="congrats-modal">
        <div class="congrats-message">
            <h1>Game Over! Please Protect Our Pipes</h1>
            <h4>Only Flush the "3-Ps": Pee ðŸ’§- Poo ðŸ’© - toilet Paper ðŸ§»</h4>
            <button id="closeModalButtonGameOver" class="closeModalButton">OK</button>
        </div>
    </div>
    <div id="legendContent" class="legend-content">
        <h3>Map Legend</h3>
        <table class="icon-text-table">
            <tr>
                <td><i class="fa-solid fa-minus fa-flip fa-2xl" style="color: #B197FC;"></i></td>
                <td>Flush Path</td>
            </tr>
            <tr>
                <td><i class="fa-solid fa-pump-soap fa-beat fa-2x" style="color: #ed0c0c;"></i></td>
                <td>LS</td>
            </tr>
            <tr>
                <td><i class="fa-solid fa-city fa-beat fa-2x" style="color: #120FE6;"></i></td>
                <td>WWTP</td>
            </tr>
            <tr>
                <td><i class="fa-solid fa-minus fa-2xl" style="color: #e60a0a;"></i></td>
                <td>Sewer Lines</td>
            </tr>
            <tr>
                <td><i class="fa-regular fa-circle"></i></td>
                <td>Sewer Manholes</td>
            </tr>
            <tr>
                <td><i class="fa-solid fa-ghost fa-beat fa-2x"></i></td>
                <td>Sewer Overflow <br/><button id="morelegendButton" class="legend-button-small">More Info...<i class="fa-solid fa-ghost fa-beat" style="color: green"></i></button></td>
            </tr>            
        </table>

        <hr />
        <div class="switch-container">
            <input type="checkbox" class="toggle-switch-checkbox" id="manholeToggle">
            <label class="toggle-switch-label" for="manholeToggle"></label>
            <h4>&nbsp;More Layers</h4>
        </div>
        <div class="switch-container">
            <input type="checkbox" class="toggle-switch-checkbox" id="onlyFlush">
            <label class="toggle-switch-label" for="onlyFlush"></label>
            <h4>&nbsp;Only Flush</h4>
        </div>
        <div class="switch-container">
            <input type="checkbox" class="toggle-switch-checkbox" id="ssoOn">
            <label class="toggle-switch-label" for="ssoOn"></label>
            <h4>&nbsp;Sewer Overflow</h4>
        </div>        
        <hr />
        <div class="switch-container">
            <input type="checkbox" class="toggle-switch-checkbox" id="gameOn">
            <label class="toggle-switch-label" for="gameOn"></label>
            <h4>&nbsp;Game On</h4>
        </div>
        <hr />
        <!-- About button -->
        <button id="aboutButton" class="legend-button">About</button>
        <div><i style="font-size:14px; ">For Kiddos Learning Only</i></div>
        <!-- Toggle switch for manhole layers -->
    </div>

    <script>
        document.getElementById('scoreContainer').style.display = 'none';
        function adjustMapHeight() {
            var mapElement = document.getElementById('map');
            var windowHeight = window.innerHeight;
            mapElement.style.height = windowHeight + 'px';
        }

        // Adjust the height on initial load
        adjustMapHeight();

        // Adjust the height whenever the window is resized
        window.addEventListener('resize', adjustMapHeight);
        document.getElementById('legendContent').style.display = 'none';
        document.getElementById('legendContent').style.display = 'none';
        document.getElementById('toggleButton').onclick = function () {
            var contentDiv = document.getElementById('legendContent');
            var isHidden = contentDiv.style.display === 'none';
            contentDiv.style.display = isHidden ? 'block' : 'none';

            var icon = this.querySelector('i');
            if (isHidden) {
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');
            } else {
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');
            }
        };
        document.getElementById('aboutButton').onclick = function () {
            closeSummaryCard('summaryCard');
            document.getElementById('aboutMe').style.display = 'block';
        };

        document.getElementById('morelegendButton').onclick = function () {
            closeSummaryCard('summaryCard');
            document.getElementById('morelgendModal').style.display = 'block';
        };

        document.getElementById('manholeToggle').onchange = function () {
            toggleManholeLayers();
        };

        document.getElementById('onlyFlush').onchange = function () {
            toggleOnlyFlush();
        };
        document.getElementById('ssoOn').onchange = function () {
            if(document.getElementById('ssoOn').checked === true){
                if(queryResultSSO !== null){
                    displayPointsOnMap(queryResultSSO);
                }
            } else {
                ghostMarkers.forEach(marker => {
                    map.removeLayer(marker); // Remove each marker from the map
                });
                document.getElementById('gameOn').checked = false;
                //ghostMarkers = []; 
            }
        };
        function setGameOn() {
            startMovingGhosts();
            try{
                unifiedBoundary_warzone=L.geoJSON(unifiedBoundary.generalBound).addTo(map);
            } catch (e){
                console.log(e);
            }
            if (currentLocationIcon === null) {
                return;
            }
            LScurrentMarker.setIcon(pumpIcon);
            // Enable game features
            //map.on('click', gameClickHandler); // Assuming this is already defined
            map.on('click', function (e) {
                firePlayerBullet(e.latlng);
            });
            showScoreLabel(true); // Assuming this function shows the game score
            if (geojsonData_game !== null) {
                // Other game initialization code...
                startBulletFiring(); // Assuming this function is already defined
            }


            // Enable dragging for the currentLocationIcon
            currentLocationIcon.dragging.enable();

            // Handle drag start and end to disable/enable map dragging
            currentLocationIcon.on('dragstart', function (e) {
                map.dragging.disable();
            });
            currentLocationIcon.on('dragend', function (e) {
                map.dragging.enable();
                var newPosition = e.target.getLatLng();

                // Check if the new position is within the boundary
                if (isPointInsideBoundary(newPosition, unifiedBoundary.generalBound)) {
                    currentLocationIcon.setLatLng(newPosition);
                    try {
                        checkForGoldCollection(newPosition);
                    } catch (error) {
                        console.log("Error after dragging: " + error.message);
                    }
                } else {
                    console.log("New position is outside the boundary. Not updating position.");
                }
            });
        }
        function setGameOff() {
            // Disable game features
            map.off('click', function (e) {
                firePlayerBullet(e.latlng);
            });
            showScoreLabel(false); // Assuming this function hides the game score

            if (currentLocationIcon !== null) {
                // Disable dragging for the currentLocationIcon
                currentLocationIcon.dragging.disable();

                // Reset the marker to its initial position
                currentLocationIcon.setLatLng([flusingPoint[1], flusingPoint[0]]);
            }
            stopMovingGhosts();
            if(unifiedBoundary_warzone!==null){
                map.removeLayer(unifiedBoundary_warzone);
            }
        }
        document.getElementById('gameOn').onchange = function () {
            if (this.checked) {
                score = 0;
                document.getElementById('score').textContent = score;
                document.getElementById('ssoOn').checked = true;
                setGameOn();
            } else {
                setGameOff();
            }
        };
        // Configuration
        const config = {
            esri_basemap: true,
            mapCenter: [29.76, -95.37], // Houston's coordinates
            initialZoom: 13,
            layerTransparency: 0.4,
            layerTransparencyView: 1,
            minimumZoomLevel: 16,
            zoomControl: false,
            maxZoom: 19,
            geoJsonStyle: {
                color: "#0000FF",
                weight: 8,
                opacity: 0.4
            }
        };
        var mainData = {
        };;
        makeDraggable([document.getElementById('cardHeader'), document.getElementById('notification')], document.getElementById('summaryCard'));
        makeDraggable([document.getElementById('cardHeader_about')], document.getElementById('aboutMe'));
        closeSummaryCard('aboutMe');
        closeSummaryCard('morelgendModal');
        closeSummaryCard('summaryCard');
        var currentGeoJsonLayer = null;
        var currentLocationIcon = null;
        var currentLocationIcoSpin = null;
        var currentGeoJsonLayerLine = null;
        var geojsonData_game = null;
        var score = 0; // Initialize score
        document.getElementById("loadingModal").style.display = "none";
        // Initialize Map
        const map = L.map('map', {
            center: config.mapCenter,
            zoom: config.initialZoom,
            maxZoom: config.maxZoom,
            zoomControl: config.zoomControl // Disable the default zoom control
        });

        // Add a toilet marker
        var toiletIcon = L.divIcon({
            className: 'fa-icon',
            html: '<i class="fa-solid fa-poo fa-4x fa-beat" style="color: #8b4513;"></i>',
            iconSize: [40, 40], // size of the icon in pixels
            iconAnchor: [20, 20] // point of the icon which will correspond to marker's location
        });
        var toiletIconAction = L.divIcon({ //<i class="fa-solid fa-toilet-paper"></i>
            className: 'fa-icon',
            html: '<i class="fa-solid fa-poo-storm fa-shake fa-4x" style="color:#e8e117;"></i>',
            iconSize: [40, 40], // size of the icon in pixels
            iconAnchor: [20, 20] // point of the icon which will correspond to marker's location
        });
        var gemIcon = L.divIcon({ //<i class="fa-solid fa-toilet-paper"></i>
            className: 'fa-icon',
            html: '<i class="fa-solid fa-toilet-paper fa-beat-fade fa-2x" style="color:#9c2eb2;"></i>',
            iconSize: [30, 30], // size of the icon in pixels
            iconAnchor: [10, 20] // point of the icon which will correspond to marker's location
        });


        var ghoshIcon = L.divIcon({ //<i class="fa-solid fa-toilet-paper"></i>
            className: 'fa-icon',
            html: '<i class="fa-solid fa-ghost fa-shake fa-3x" style="color: #d80e18;"></i>',
            iconSize: [30, 30], // size of the icon in pixels
            iconAnchor: [10, 20] // point of the icon which will correspond to marker's location
        });

        var gemIconSmall = L.divIcon({ //<i class="fa-solid fa-toilet-paper"></i>
            className: 'fa-icon',
            html: '<i class="fa-solid fa-toilet-paper fa-beat-fade" style="color:#9c2eb2;"></i>',
            iconSize: [20, 20], // size of the icon in pixels
        });
        var bulletIcon = L.divIcon({
            className: 'fa-icon',
            html: '<i class="fa-brands fa-firefox fa-spin-pulse" style="color: #ff0000;"></i>',
            iconSize: [20, 20]
        });
        var spinLocation = L.divIcon({
            className: 'fa-icon',
            html: '<i class="fa-solid fa-crosshairs fa-spin fa-2xl" style="color: #007bff;"></i>',
            iconSize: [30, 30], // size of the icon in pixels
            iconAnchor: [0, 15] // point of the icon which will correspond to marker's location
        });
        var pumpIcon = L.divIcon({
            className: 'fa-icon',
            html: '<i class="fa-solid fa-pump-soap fa-beat fa-3x" style="color: #ed0c0c;"></i>',
            iconSize: [30, 30], // size of the icon in pixels
            iconAnchor: [10, 20] // point of the icon which will correspond to marker's location
        });

        var pumpIconBlue = L.divIcon({
            className: 'fa-icon',
            html: '<i class="fa-solid fa-pump-soap fa-beat fa-3x" style="color: #3ea4f0;"></i>',
            iconSize: [30, 30], // size of the icon in pixels
            iconAnchor: [10, 20] // point of the icon which will correspond to marker's location
        });

        var wwtpIcon = L.divIcon({
            className: 'fa-icon',
            html: '<i class="fa-solid fa-city  fa-3x  fa-beat" style="color: #120FE6;"></i>',
            iconSize: [30, 30], // size of the icon in pixels
            iconAnchor: [10, 20] // point of the icon which will correspond to marker's location
        });

        if (config.esri_basemap === true) {
            L.esri.basemapLayer('Streets').addTo(map);
        }
        else {
            //L.esri.basemapLayer('Streets').addTo(map);
            L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}', {
                attribution: 'Not for official use or planning | <a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
                maxZoom: 18,
                id: 'mapbox/streets-v11', // or any other Mapbox style
                tileSize: 512,
                zoomOffset: -1,
                accessToken: 'pk.eyJ1IjoibWF0aGhvYW5nIiwiYSI6ImNsc3I2djRwYjE1ODYyanBiZ2E1djltbDkifQ.nqI0jOWkftuTKgHx6m8mcw' // Replace with your Mapbox access token
            }).addTo(map);
        }
        // Layer Definitions
        const gravityMainLayer = createEsriLayer("https://geogimsms.houstontx.gov/arcgis/rest/services/HW/WasteWaterUtilities_gx/MapServer", [1], config.layerTransparency, true);
        const forceMainLayer = createEsriLayer("https://geogimsms.houstontx.gov/arcgis/rest/services/HW/WasteWaterUtilities_gx/MapServer", [4], config.layerTransparency, true);
        const lsWwtpLayer = createEsriLayer('https://geogimsms.houstontx.gov/arcgis/rest/services/HW/WasteWaterUtilities_gx/MapServer', [16], config.layerTransparency, true);
        const lsWwtpLabelLayer = createEsriLayer('https://geogimsms.houstontx.gov/arcgis/rest/services/HW/WasteWaterUtilities_gx/MapServer', [17], config.layerTransparency, true);

        const gravityMainLayerlabel = createEsriLayer("https://geogimsms.houstontx.gov/arcgis/rest/services/HW/WasteWaterUtilities_gx/MapServer", [2], config.layerTransparency, false);
        const manholeLayer = createEsriLayer('https://geogimsms.houstontx.gov/arcgis/rest/services/HW/WasteWaterUtilities_gx/MapServer', [12], config.layerTransparencyView, false);

        const manholeLayerLabel = createEsriLayer('https://geogimsms.houstontx.gov/arcgis/rest/services/HW/WasteWaterUtilities_gx/MapServer', [13], config.layerTransparencyView, false);


        // Utility Functions
        function createEsriLayer(url, layers, opacity, addIn) {
            if (addIn === true) {
                return L.esri.dynamicMapLayer({ url, layers, opacity }).addTo(map);
            } else {
                return L.esri.dynamicMapLayer({ url, layers, opacity });

            }
        }
        document.getElementById('lastFlushButton').addEventListener('click', function () {
            if (Object.keys(mainData).length === 0) {
                var NoData = {
                    header: "Ready, Set, Flush! Double Click/Tap anywhere on the map to start a watery whirlwind adventure!", // Add your header text here
                    distance: 'Flush to see the journey',
                    time: 'Flush to travel in time',
                    communities: ['Traveling']
                };
                showSummaryCard(NoData, true);
            } else {
                showSummaryCard(mainData, false);
            }
        });

        function showSummaryCard(data, notification) {
            if (notification === false) {
                document.getElementById('distanceTraveled_container').style.display = '';
                document.getElementById('timeToWWTP_container').style.display = '';
                document.getElementById('communitiesPassed').style.display = '';
                document.getElementById('card-note-notification').style.display = '';
                document.getElementById('notification').style.display = '';
                document.getElementById('communitiesPassed_').style.display = '';
                document.getElementById('generalRoute_container').style.display = '';
                // Populate the summary card with data
                // Populate the summary card with data
                document.getElementById('cardHeader').textContent = data.header;
                document.getElementById('distanceTraveled').textContent = data.distance;
                document.getElementById('timeToWWTP').textContent = data.time;
                document.getElementById('generalRoute').textContent = data.generalRoute;
                document.getElementById('communitiesPassed').innerHTML = data.communities.map(c => `<li>${c}</li>`).join('');
            } else {
                document.getElementById('cardHeader').textContent = data.header;
                document.getElementById('distanceTraveled_container').style.display = 'none';
                document.getElementById('timeToWWTP_container').style.display = 'none';
                document.getElementById('communitiesPassed').style.display = 'none';
                document.getElementById('card-note-notification').style.display = 'none';
                document.getElementById('notification').style.display = 'none';
                document.getElementById('communitiesPassed_').style.display = 'none';
                document.getElementById('generalRoute_container').style.display = 'none';
            }
            // Show the summary card
            document.getElementById('summaryCard').style.display = 'block';
        }

        function closeSummaryCard(cardName) {
            document.getElementById(cardName).style.display = 'none';
        }

        function showModal() {
            document.getElementById('loadingModal').style.display = 'flex'; // Use 'flex' to enable flexbox properties
        }
        function hideModal() {
            document.getElementById('loadingModal').style.display = 'none';
        }
        let manholeLayersAdded = false;
        function toggleManholeLayers() {
            if (manholeLayersAdded) {
                map.removeLayer(manholeLayer);
                map.removeLayer(manholeLayerLabel);
                map.removeLayer(gravityMainLayerlabel);
                config.layerTransparency = 0.4;
                setLayerVisibility(config.layerTransparency);
                if (document.getElementById('onlyFlush').checked === true) {
                    document.getElementById('onlyFlush').checked = false;
                    toggleOnlyFlush();
                }
            } else {
                manholeLayerLabel.addTo(map);
                manholeLayer.addTo(map);
                gravityMainLayerlabel.addTo(map);
                map.removeLayer(gravityMainLayer);
                gravityMainLayer.addTo(map); //well! this is to bring the gravityMainLayer to the bottom
                map.removeLayer(forceMainLayer);
                forceMainLayer.addTo(map);   //well! this is to bring the forceMainLayer to the bottom              
                config.layerTransparency = 1;
                setLayerVisibility(config.layerTransparency);
            }
            manholeLayersAdded = !manholeLayersAdded;
        }
        let onlyFlush = false;
        toggleOnlyFlush(onlyFlush);

        function toggleSSO(){

        }

        function toggleOnlyFlush() {
            if (onlyFlush) {
                map.removeLayer(manholeLayer);
                map.removeLayer(manholeLayerLabel);
                map.removeLayer(gravityMainLayerlabel);
                map.removeLayer(gravityMainLayer);
                map.removeLayer(forceMainLayer);
                map.removeLayer(lsWwtpLayer);
                map.removeLayer(lsWwtpLabelLayer);
                if (document.getElementById('manholeToggle').checked === true) {
                    document.getElementById('manholeToggle').checked = false;
                    toggleManholeLayers();
                }

            } else {
                //gravityMainLayerlabel.addTo(map);
                gravityMainLayer.addTo(map); //well! this is to bring the gravityMainLayer to the bottom
                forceMainLayer.addTo(map);   //well! this is to bring the forceMainLayer to the bottom              
                lsWwtpLayer.addTo(map);   //well! this is to bring the forceMainLayer to the bottom              
                lsWwtpLabelLayer.addTo(map);   //well! this is to bring the forceMainLayer to the bottom                       
            }
            onlyFlush = !onlyFlush;
        }
        function removeAllLayer() {
            try {
                if (currentGeoJsonLayer !== null) map.removeLayer(currentGeoJsonLayer);
                if (LScurrentMarker !== null) map.removeLayer(LScurrentMarker);
                if (WWTPcurrentMarker !== null) map.removeLayer(WWTPcurrentMarker);
                if (currentGeoJsonLayerLine !== null) map.removeLayer(currentGeoJsonLayerLine);
                if (currentLocationIcon !== null) map.removeLayer(currentLocationIcon);
                if (currentLocationIcoSpin !== null) map.removeLayer(currentLocationIcoSpin);
                if (searchMarker !== null) map.removeLayer(searchMarker);
                if (searchMarker !== null) map.removeLayer(searchMarker);
                if (unifiedBoundary_warzone !== null) map.removeLayer(unifiedBoundary_warzone);
                try{
                    clearAllGhostMarkers();
                } catch (e){
                    console.log(e);
                }
                LScurrentMarker = null;
                WWTPcurrentMarker = null;
                currentGeoJsonLayer = null;
                currentGeoJsonLayerLine = null;
                currentLocationIcoSpin = null;
            } catch (e) {
                console.log(e);
            }
        }
        let flusingPoint = null;
        // Function to add GeoJSON to the map
        function addGeoJsonToMap(geojsonData) {

            // Remove the previous GeoJSON layer if it exists
            removeAllLayer();

            currentGeoJsonLayer = L.geoJSON(geojsonData, {
                style: function (feature) {
                    return {
                        color: config.geoJsonStyle.color, // Example color
                        weight: config.geoJsonStyle.weight,
                        opacity: config.geoJsonStyle.opacity,
                        lineCap: 'round',
                        dashArray: '10, 20',
                        dashOffset: '0',
                        className: (feature.properties.SUBTYPECD == 1 || feature.properties.SUBTYPECD == 2) ? 'heavy-traffic-animation' : 'light-traffic-animation'
                    };
                }
            }).addTo(map);

            currentGeoJsonLayerLine = L.geoJSON(geojsonData, {
                style: function (feature) {
                    return {
                        color: "#0000FF",
                        weight: 12,       // Thickness of the line
                        opacity: 0.2     // Transparency
                    };
                }
            }).addTo(map);
            // Zoom to the bounds of the GeoJSON layer
            if (geojsonData.features && geojsonData.features.length > 0) {
                var bounds = currentGeoJsonLayer.getBounds();
                map.fitBounds(bounds);
            }
            flusingPoint = geojsonData.features[0].geometry.coordinates[0];
            currentLocationIcoSpin = L.marker([flusingPoint[1], flusingPoint[0]], { icon: spinLocation })
                .addTo(map)
       
            currentLocationIcon = L.marker([flusingPoint[1], flusingPoint[0]], {
                icon: toiletIcon,
                draggable: false,
                zIndexOffset: 1000
            }).addTo(map);

        }

        function checkZoomLevel() {
            const currentZoom = map.getZoom();
            console.log(currentZoom);
            if (currentZoom < config.minimumZoomLevel) {
                setLayerVisibility(0); // Hide layers
            } else {
                setLayerVisibility(config.layerTransparency); // Show layers
            }
        }

        function setLayerVisibility(opacity) {
            gravityMainLayer.setOpacity(opacity);
            forceMainLayer.setOpacity(opacity);
            lsWwtpLayer.setOpacity(opacity);
            lsWwtpLabelLayer.setOpacity(opacity);
            gravityMainLayerlabel.setOpacity(opacity);
            manholeLayer.setOpacity(opacity);
            manholeLayerLabel.setOpacity(opacity);
        }

        var LScurrentMarker = null; // This will hold the current marker
        var WWTPcurrentMarker = null; // This will hold the current marker
        var queryResultSSO = null;
        var     ghostMarkers = []

        async function displayPointsOnMap(queryResult) {
            // Mapping from cause to color
            var causeToColor = {
                "Collection System - Temporary Blockage": "Teal",
                "Collection System - Grease Blockage": "Red",
                "Collection System - Structural Blockage": "Black",
                "Pump/Lift Station - Structural Failure": "Yellow",
                "Collection System - Wet Weather": "Blue",
                "Collection System - Structural Failure": "Black",
                "Pump/Lift Station - Instrumentation Failure": "Yellow",
                "Pump/Lift Station - Hydraulic Overload": "Yellow",
                "Pump/Lift Station - Mechanical Failure": "Yellow",
                "Pump/Lift Station - Electrical Failure": "Yellow",
                "WWTP - Mechanical Failure": "Yellow",
                "Service Lateral - Temporary Blockage": "Teal",
                "Service Lateral - Grease Blockage": "Red",
                "Rags/Wipes": "Purple",
                "Grease Blockage": "Red",
                "Roots": "Green",
                "Collection System Temporary Blockage": "Black",
                "Collection System Structural Blockage": "Black"
            };

            queryResult.features.forEach(function (feature) {
                var lat = feature.geometry.y;
                var lng = feature.geometry.x;
                var cause = feature.attributes.CAUSE;
                var color = causeToColor[cause] || "gray"; // Default to gray if cause is not in the list

                // Create a ghost icon for each point and set its color
                var ghostIcon = L.divIcon({
                    className: 'fa-icon',
                    html: `<i class="fa-solid fa-ghost fa-shake fa-3x" style="color: ${color};"></i>`,
                    iconSize: [30, 30],
                    iconAnchor: [0, 0] // Adjusted to center the icon over the point
                });

                // Create a marker with the ghost icon and add it to the map
                var marker = L.marker([lat, lng], {
                    icon: ghostIcon,
                    draggable: false
                }).addTo(map);

                // Add a popup to the marker
                var popupContent = `Address: ${feature.attributes.ADDRESS}<br>`
                    + `Cause: ${feature.attributes.CAUSE}<br>`
                    + `System: ${feature.attributes.SYSTEM}<br>`
                    + `StartDate: ${(new Date(feature.attributes.STARTDATE)).toDateString()}<br>`
                    + `ID: ${feature.attributes.EXCURSIONID}`;
                //marker.bindPopup(popupContent);
                marker.bindTooltip(popupContent, { permanent: false, direction: 'top' });
                ghostMarkers.push(marker);
            });
        }
        let unifiedBoundary = null;
        let unifiedBoundary_warzone = null;
        async function runTrace(lng, lat) {
            showModal();
            geojsonData_game = null;
            // Remove the previous GeoJSON layer if it exists
            await removeAllLayer();
            try {
                const initialUnitId = await findNearestFeatureUnitId(lng, lat);
                if (initialUnitId) {
                    //15: LS
                    const result = await queryFeaturesAndGetGeoJson(initialUnitId, 98);
                    if (result && result.geojson) {
                        let street = [];
                        let generalRoute = "";
                        result.geojson = processGeoJsonData(result.geojson);
                        geojsonData_game = result.geojson;
                        //let bbox = calculateBoundingBox(result.geojson);

                        addGeoJsonToMap(result.geojson);
                        unifiedBoundary = await calculateUnifiedBoundaryWithBuffer_polygon_V2(result.geojson,0.002,500); //unit: feet
                        //L.geoJSON(unifiedBoundary.simplifiedBuffer).addTo(map);    
                        
                        let neighborhood = await queryGISWithinPolygon( "https://mycity2.houstontx.gov/pubgis02/rest/services/HoustonMap/Administrative_Boundary/MapServer/3/query",
                                                                            "1=1",
                                                                            unifiedBoundary.esriPolygonGeometry);                                                
                        if(document.getElementById('ssoOn').checked === true){
                            queryResultSSO = await queryGISWithinPolygon(   "https://services.arcgis.com/NummVBqZSIJKUeVR/arcgis/rest/services/RSSO_Package/FeatureServer/0/query",
                                                                            "SYSTEM like '%blic%' AND STARTDATE >= date '2021-01-01'",
                                                                            unifiedBoundary.esriPolygonGeometry);
                            await displayPointsOnMap(queryResultSSO);
                        }                        
                        hideModal();
                        //find first LiftStation
                        let firstLS = result.stopPoints.find(obj => obj.type === 15);
                        if (firstLS != null) {
                            firstLS = await findLSWWTP(firstLS.type, firstLS.unitID);
                        }

                        let lastStopPoint = result.stopPoints[result.stopPoints.length - 1];
                        let lastStopPoint_Result = await findLSWWTP(lastStopPoint.type, lastStopPoint.unitID);
                        if (lastStopPoint_Result == null) { //get
                            lastStopPoint_Result = await findLSWWTP(lastStopPoint.type, lastStopPoint.unitID);
                            for (let i = result.geojson.features.length - 1; i >= 0; i--) {
                                lastStopPoint_Result = await findLSWWTP(result.geojson.features[i].properties.MAINCOMP2, result.geojson.features[i].properties.UNITID2);
                                if (lastStopPoint_Result != null) {
                                    break;
                                }
                            }
                        }
                        if (firstLS == null) {
                            generalRoute = "Guess what happens when you flush? It's like a water race to the 'Clean Team Castle', zooming directly to the treatment plant " + lastStopPoint_Result.info.FACILITYNAME + " at " + lastStopPoint_Result.info.ADDRESS + "for a super splashy makeover";

                        } else {
                            generalRoute = "Every time you flush, it's like a mini-water slide adventure for the water! It zooms down to the 'Super Lift Station' " + firstLS.info.FACILITYNAME + " at " + firstLS.info.ADDRESS + "  then whooshes through secret tunnels all the way to the 'Clean-up Club' WWTP at  " + lastStopPoint_Result.info.ADDRESS;
                            placeMarker(firstLS.location.y, firstLS.location.x, firstLS.info.FACILITYNAME, "LS");
                        }
                        await placeMarker(lastStopPoint_Result.location.y, lastStopPoint_Result.location.x, lastStopPoint_Result.info.FACILITYNAME, "WWTP")
                        let calculation = await calculateRoute(result.geojson.features);
                        mainData = {
                            header: "Near By " + result.geojson.features[0].properties.ADDRESS, // Add your header text here
                            generalRoute: generalRoute,
                            distance: `The flush travels ${calculation.total_len_ft} feet (${calculation.total_len_mi}  miles) through the sewer network before reaching the COH treatment facility.`,
                            time: `Your flush goes on a wild ride! It could zip to the treatment plant in just  ${calculation.total_hour_min} hours, , or take a leisurely journey up to ${calculation.total_hour_max} hours during sunny weather fun times.`,
                            communities: getUniqueSuperNeighborhood(neighborhood.features)
                        };
                        if (document.getElementById('gameOn').checked === true) {
                            setGameOn();
                        } else {
                            setGameOff();
                        }
                        showSummaryCard(mainData, false);
                    } else {
                        console.log('No GeoJSON data found.');
                    }
                } else if (initialUnitId == null || initialUnitId == "") {
                    var noConnection = {
                        header: "Likely, you are not connecting to any City of Houston Sanitary Sewer System", // Add your header text here
                        distance: 'Not Applicable',
                        time: 'Not Applicable',
                        communities: ['Not Available']
                    };
                    hideModal();
                    showSummaryCard(noConnection, true);
                }
            } catch (error) {
                console.error('Error:', error);
            }

        }
        function placeMarker(lat, long, text, type) {
            try {
                if (type == "LS") {
                    markerOptions = { icon: new L.Icon.Default() };
                    LScurrentMarker = L.marker([lat, long], { icon: pumpIcon });
                    LScurrentMarker.addTo(map);
                    LScurrentMarker.bindPopup(text + " LS");
                    LScurrentMarker.bindTooltip(text + " LS").openTooltip();
                } else {
                    WWTPcurrentMarker = L.marker([lat, long], { icon: wwtpIcon });//wwtpIcon
                    WWTPcurrentMarker.addTo(map);
                    WWTPcurrentMarker.bindPopup(text);
                    WWTPcurrentMarker.bindTooltip(text).openTooltip();
                }
            } catch (e) {
                console.log(e);
            }
        }
        map.on('dblclick', async function (e) {
            closeSummaryCard('summaryCard');
            runTrace(e.latlng.lng, e.latlng.lat)
        });

        function gameClickHandler(e) {
            // Get the lat and lng of the clicked point
            var clickedLat = e.latlng.lat;
            var clickedLng = e.latlng.lng;

            // Check if currentLocationIcon already exists
            if (currentLocationIcon) {
                // Move the currentLocationIcon to the clicked location
                animateMarker(currentLocationIcon, e.latlng, 1000);
            } else {
                // Create currentLocationIcon if it doesn't exist
            }
            try {
                checkForGoldCollection(currentLocationIcon.getLatLng());
            } catch (e) {
                console.log("First enable the game " + e.message);
            }
        }

        // Additional logic here (e.g., checking if the click is along the flush path)

        function animateMarker(marker, destination, duration) {
            var startLatLng = marker.getLatLng();
            var endLatLng = new L.LatLng(destination.lat, destination.lng);

            var startTime = Date.now();
            var timer = setInterval(function () {
                var currentTime = Date.now();
                var progress = (currentTime - startTime) / duration;

                if (progress > 1) {
                    progress = 1;
                    clearInterval(timer);
                }

                var lat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * progress;
                var lng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * progress;

                marker.setLatLng([lat, lng]);

                if (progress === 1) {
                    clearInterval(timer);
                }
            }, 10); // The smaller this number, the smoother the animation
        }
        // Event Listeners
        map.on('zoomend', checkZoomLevel);
        checkZoomLevel(); // Initial check
        var searchMarker = null;
        var geocoder = L.Control.geocoder({
            position: 'topright',
            defaultMarkGeocode: false
        }).addTo(map);

        geocoder.on('markgeocode', function (e) {
            var bbox = e.geocode.bbox;
            var latLng = e.geocode.center; // Latitude and Longitude of the searched location
            map.panTo(latLng);
            if (searchMarker) {
                map.removeLayer(searchMarker);
            }
            // Add a new search marker
            searchMarker = L.marker(latLng).addTo(map).bindPopup(e.geocode.name).openPopup();

            // Clear previous GeoJSON layer
            removeAllLayer();
            runTrace(latLng.lng, latLng.lat)

        });
        document.getElementById('currentLocationButton').addEventListener('click', function () {
            map.locate({ setView: true, maxZoom: config.initialZoom });

            map.on('locationfound', function (e) {
                runTrace(e.latlng.lng, e.latlng.lat);
            });

            map.on('locationerror', function (e) {
                alert("Location access denied.");
            });
        });
        // Function to add gold markers

        function toggleIconColor(color) {
            // Update the icon's HTML with the new color
            var newHtml = '<i class="fa-solid fa-poo fa-4x fa-beat" style="color: ' + color + ';"></i>';
            currentLocationIcon.setIcon(L.divIcon({
                className: 'fa-icon',
                html: newHtml,
                iconSize: [40, 40],
                iconAnchor: [20, 20]
            }));
        }
        function blinkAndChangeColor() {
            let colors = ["#8b4513", "red", "#8b4513", "red", "blue", "#8b4513", "yellow", "red", , "#8b4513"]; // Sequence of colors
            let currentIndex = 0; // Start with the first color

            let intervalId = setInterval(() => {
                if (currentIndex < colors.length) {
                    toggleIconColor(colors[currentIndex]);
                    currentIndex++;
                } else {
                    clearInterval(intervalId); // Stop blinking after the last color
                }
            }, 25); // Adjust the speed of color change as needed
        }
        function checkForGoldCollection() {
            var someThresholdDistance = 15; // Threshold distance in meters
            var currentLocation = currentLocationIcon.getLatLng(); // Get current location of the toilet icon

            if (checkCollisionWithLiftStation()) {
                    fireBulletFromLiftStation();
            }
        }

        function clearAllGhostMarkers() {
            ghostMarkers.forEach(marker => {
                map.removeLayer(marker); // Remove each marker from the map
            });

            ghostMarkers = []; 
        }
        var playerBullets = 0;
        // Assuming you have a function to update the player's score
        function updateScore() {
            score++; // Increment score
            document.getElementById('score').textContent = score; // Update score display
        }

        function firePlayerBullet(targetLatLng) {
            var playerPosition = currentLocationIcon.getLatLng();
            var bullet = L.marker(playerPosition, { icon: gemIconSmall }).addTo(map);

            animateMarker_bullet(bullet, targetLatLng, 500, function () {
                // Bullet animation complete, check for hit with LS or ghosts
                if (checkPlayerBulletHit(bullet, LScurrentMarker)) {
                    if(ghostMarkers.length === 0){ //LS is hit only when no more ghost
                        console.log("Hit on LS!");
                        stopBulletFiring(); // Assuming this function stops all bullet firings
                        LScurrentMarker.setIcon(pumpIconBlue); // Assuming this changes the icon of the LS to indicate it's hit
                        //showCongratulationsLSKilled();
                        showCongratulations();
                    }
                } else {
                    // No hit with LS, check against all ghosts
                    let hit = false; // Flag to track if we hit a ghost
                    ghostMarkers.forEach((ghostMarker, index) => {
                        if (checkPlayerBulletHit(bullet, ghostMarker)) {
                            map.removeLayer(ghostMarker); // Remove the hit ghost
                            ghostMarkers.splice(index, 1); // Remove ghost from array
                            score += 1; // Increment score
                            console.log("Ghost hit!");
                            hit = true; // Mark that we hit a ghost
                        }
                    });
                    if (!hit) {
                        console.log("No hit detected.");
                    }
                }
                map.removeLayer(bullet); // Remove the bullet in all cases
                document.getElementById('score').textContent = score; // Update score display
            });
        }


        function checkPlayerBulletHit(bullet, target) {
            var hitThreshold = 20; // Threshold distance in meters
            var bulletPosition = bullet.getLatLng();
            var targetPosition = target.getLatLng();
            console.log(bulletPosition.distanceTo(targetPosition));
            if (bulletPosition.distanceTo(targetPosition) < hitThreshold) {
                return true; // Indicate a hit was detected
            }
            return false; // No hit detected
        }

        function showScoreLabel(visible) {
            var scoreContainer = document.getElementById('scoreContainer');
            if (visible) {
                scoreContainer.style.display = 'block'; // Show the score label
            } else {
                scoreContainer.style.display = 'none'; // Hide the score label
            }
        }
        function showCongratulations() {
            var congratsModal = document.getElementById('congratsModal');
            congratsModal.style.visibility = 'visible';
            stopBulletFiring(); // Stop firing bullets
            console.log('All ghost kills collected!');
            // Create and add balloons to the modal
            var closeButton = document.getElementById('closeModalButton');
            closeButton.onclick = function () {
                congratsModal.style.visibility = 'hidden';
            };
            // Optional: Set a timeout to hide the modal and clear balloons after a certain time
            setTimeout(function () {
                congratsModal.style.visibility = 'hidden';
            }, 3000); // 10 seconds
        }

        function showCongratulationsLSKilled() {
            var congratsModal = document.getElementById('congratsModalLS');
            congratsModal.style.visibility = 'visible';
            stopBulletFiring(); // Stop firing bullets
            clearAllBullets_ls();
            console.log('KIlled LS');
            // Create and add balloons to the modal
            var closeButton = document.getElementById('closeModalButtonLS');
            closeButton.onclick = function () {
                congratsModal.style.visibility = 'hidden';
            };
            // Optional: Set a timeout to hide the modal and clear balloons after a certain time
            setTimeout(function () {
                congratsModal.style.visibility = 'hidden';
            }, 3000); // 10 seconds
        }
        function checkCollisionWithLiftStation() {
            var someThresholdDistance = 15;
            if (document.getElementById('gameOn').checked === false || LScurrentMarker === null) {
                return; // Exit the function if the game is not on
            }            
            var pooPosition = currentLocationIcon.getLatLng(); // Get current location of the poo icon
            var liftStationPosition = LScurrentMarker.getLatLng(); // Assuming LScurrentMarker is your Lift Station marker

            // Check if poo icon is close enough to the Lift Station marker
            if (pooPosition.distanceTo(liftStationPosition) < someThresholdDistance) {
                // Collision detected
                return true;
            }
            return false;
        }
        //gameOn

        var bulletFiringInterval = null; // This will hold the interval for firing bullets
        var movingGhostInterval = null; // This will hold the interval for firing bullets
        function fireBulletFromLiftStation() {
            if (document.getElementById('gameOn').checked === false || LScurrentMarker === null) {
                return; // Exit the function if the game is not on
            }

            var proximityThreshold = 80; // Threshold distance in meters

            var lsPosition = LScurrentMarker.getLatLng();
            var pooPosition = currentLocationIcon.getLatLng();

            if (lsPosition.distanceTo(pooPosition) <= proximityThreshold) {
                // Only fire if the poo icon is close to the lift station
                fireBullet(lsPosition);
            }
        }
        // Start firing bullets
        function startBulletFiring() {
            bulletFiringInterval = setInterval(fireBulletFromLiftStation, 2000);
        }

        // Stop firing bullets
        function stopBulletFiring() {
            clearInterval(bulletFiringInterval);
        }
        // Start firing bullets
        function startMovingGhosts() {
            console.log("total ghost number: ",ghostMarkers.length);
            if(ghostMarkers.length === 0 || document.getElementById('ssoOn').checked === false){
                return ;
            }
            movingGhostInterval=setInterval(function () {
                ghostMarkers.forEach(moveGhosts);
        }, 200); // Move ghosts every 2 seconds, adjust as needed            
        }

        // Stop firing bullets
        function stopMovingGhosts() {
            clearInterval(movingGhostInterval);
        }        

        function onHit() {
            console.log("Hit! You lose.");
            clearInterval(bulletFiringInterval); // Stop firing bullets
            stopMovingGhosts();
            score = 0;
            document.getElementById('score').textContent = score;
            showGameOver(); // Show game over modal
            currentLocationIcon.setLatLng([geojsonData_game.features[0].geometry.coordinates[0][1], geojsonData_game.features[0].geometry.coordinates[0][0]]);
            startBulletFiring();
            startMovingGhosts();
        }
        var bullets_ls = [];
        function clearAllBullets_ls() {
            try {
                bullets_ls.forEach(function (bullets_ls) {
                    map.removeLayer(bullets_ls);
                });
                bullets_ls = []; // Reset the bullets array
            } catch (e) {
                console.log(e);
            }
        }
        function fireBullet(startLatLng) {
            var bullet = L.marker(startLatLng, { icon: bulletIcon }).addTo(map); // Use a local variable
            bullets_ls.push(bullet); // Add the new bullet to the array
            var targetPoint = currentLocationIcon.getLatLng();

            // Animate the bullet towards the target point
            animateMarker_bullet(bullet, targetPoint, 1000, function () {
                checkBulletCollision(bullet, currentLocationIcon);
                map.removeLayer(bullet); // Remove this specific bullet after animation
                try {
                    map.removeLayer(bullets_ls[bullets_ls.length - 1]);
                } catch (e) {
                    ;
                }
                clearAllBullets_ls();
            });
        }
        function checkBulletCollision(bullet, target) {
            var bulletCollisionThreshold = 5;
            var bulletPosition = bullet.getLatLng();
            var targetPosition = target.getLatLng();
            if (bulletPosition.distanceTo(targetPosition) < bulletCollisionThreshold) {
                onHit();
                clearAllBullets_ls();
            }
        }
        function animateMarker_bullet(marker, destination, duration, onComplete) {
            if (duration <= 0) {
                marker.setLatLng(destination);
                if (onComplete) onComplete();
                return;
            }

            var startLatLng = marker.getLatLng();
            var endLatLng = new L.LatLng(destination.lat, destination.lng);
            var startTime = Date.now();
            var intervalRate = 10; // milliseconds, adjust for smoother or faster animation

            var timer = setInterval(function () {
                var currentTime = Date.now();
                var progress = (currentTime - startTime) / duration;
                if (progress > 1) progress = 1;

                var lat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * progress;
                var lng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * progress;
                var newLatLng = new L.LatLng(lat, lng);

                marker.setLatLng(newLatLng);

                // Check for collisions with each move step
                ghostMarkers.forEach((ghostMarker, index) => {
                    if (checkPlayerBulletHit(marker, ghostMarker)) {
                        map.removeLayer(ghostMarker); // Remove the ghost
                        ghostMarkers.splice(index, 1); // Remove the ghost from the array
                        score += 1; // Increment score
                        document.getElementById('score').textContent = score; // Update score display
                        console.log("Ghost hit during bullet movement!");
                    }
                });

                if (progress === 1) {
                    clearInterval(timer);
                    if (onComplete) onComplete();
                }
            }, intervalRate);
        }
        function showGameOver() {
            var congratsModal = document.getElementById('gameOver');
            congratsModal.style.visibility = 'visible';
            console.log('Game Over!');
            // Create and add balloons to the modal
            var closeButton = document.getElementById('closeModalButtonGameOver');
            closeButton.onclick = function () {
                congratsModal.style.visibility = 'hidden';
            };
        }

        function getRandomDirection() {
            return {
                lat: (Math.random() - 0.5) * 0.001, // small value for slow movement
                lng: (Math.random() - 0.5) * 0.001,
            };
        }

        function moveTowardsTarget(ghostMarker, targetLatLng) {
            var ghostLatLng = ghostMarker.getLatLng();
            var directionLat = targetLatLng.lat - ghostLatLng.lat;
            var directionLng = targetLatLng.lng - ghostLatLng.lng;
            var distance = Math.sqrt(directionLat * directionLat + directionLng * directionLng);
            var moveStep = 0.0003; // The step size for each movement

            // Normalize the direction vector and multiply by step size
            directionLat = (directionLat / distance) * moveStep;
            directionLng = (directionLng / distance) * moveStep;

            return {
                lat: directionLat,
                lng: directionLng,
            };
        }
        // Move the ghost marker smoothly using Leaflet's setLatLng
        function animateGhostMovement(ghostMarker, direction) {
            try{
                var currentLatLng = ghostMarker.getLatLng();
                var newLatLng = new L.LatLng(
                    currentLatLng.lat + direction.lat,
                    currentLatLng.lng + direction.lng
                );
                ghostMarker.setLatLng(newLatLng);
            }catch{
                console.log("Well! Ghost is not ready yet")
            }
        
        }
        function adjustMovementBackInside(currentLatLng, boundary) {
            // This example inverts the direction, but you can implement more sophisticated logic as needed
            let invertedDirection = {
                lat: (Math.random() - 0.5) * 0.0002, // Invert direction with a small randomization
                lng: (Math.random() - 0.5) * 0.0002,
            };

            // Ensure the adjusted direction moves the ghost back inside the boundary
            // This might involve checking multiple directions or using specific logic based on the boundary shape
            // For now, we return the inverted direction as a simple example
            return invertedDirection;
        }  
        // Main function to move the ghosts independently
        // Enhance the moveGhosts function to check for collisions after moving
        function moveGhosts(ghostMarker) {
            if(document.getElementById('ssoOn').checked === false ||unifiedBoundary === null){
                console.log("SSO not on")
                return;
            }
            // Decide the behavior of this ghost: random, chase player, etc.
            var direction = getRandomDirection(); // For example, get a random direction

            // Use the moveTowardsTarget function if you want to chase the player or move towards a point
            // direction = moveTowardsTarget(ghostMarker, currentLocationIcon.getLatLng());
    
            let newLatLng = {
                lat: ghostMarker.getLatLng().lat + direction.lat,
                lng: ghostMarker.getLatLng().lng + direction.lng,
            };
            if (isPointInsideBoundary(newLatLng, unifiedBoundary.generalBound)) {
                // Move the ghost marker smoothly
                animateGhostMovement(ghostMarker, direction);
            } else {
                // Check for collision with the player
                console.log("New position is outside the boundary. Adjusting movement.");
                let adjustedDirection = adjustMovementBackInside(ghostMarker, unifiedBoundary.generalBound);
                animateGhostMovement(ghostMarker, adjustedDirection);
            }

            // Check for collision with the player
            checkCollision(ghostMarker);
        }
        function isPointInsideWarZone(latlng, boundary) {
            // Implement the logic to check if latlng is inside the boundary
            // This might involve converting the boundary to a suitable format for a point-in-polygon check
            // For simplicity, this function returns true or false based on your logic
            return true; // Placeholder return value
        }
        function startMovingGhosts() {
            console.log("total ghost number: ",ghostMarkers.length);
            if(ghostMarkers.length === 0){
                return ;
            }
            console.log("total ghost number: ",ghostMarkers.length);
            movingGhostInterval=setInterval(function () {
                ghostMarkers.forEach(moveGhosts);
                //checkCollision();
        }, 200); // Move ghosts every 2 seconds, adjust as needed            
        }
        // Function to check for collision between ghost markers and the toilet marker
        function checkCollision(ghostMarker) {
            var COLLISION_DISTANCE = 10;
            if(ghostMarker === null){
                console.log("No ghost to check collision")
                return
            }
            if(document.getElementById('ssoOn').checked === false){
                console.log("SSO not on")
                return;
            }
            try{
                var playerPosition = currentLocationIcon.getLatLng();
                var ghostPosition = ghostMarker.getLatLng();
                var distance = playerPosition.distanceTo(ghostPosition);

                // If the distance is small enough, consider it a collision
                if (distance < COLLISION_DISTANCE) {
                    // Handle collision (e.g., end game, reduce score)
                    onCollisionDetected();
                }
            }catch(e) {
                console.log("Well! no ghost to hunt",e.message)
            }
        }

        // Function to handle what happens when a collision is detected
        function onCollisionDetected() {
            // Logic for when the player loses the game, e.g., end the game, reduce score, etc.
            console.log("Collision detected! Player loses.");
            onHit();
        }
        // Set up an interval to periodically move each ghost and check for collisions
        // Set up independent intervals for each ghost
        // Call moveGhosts for each ghost independently

    </script>
</body>

</html>
